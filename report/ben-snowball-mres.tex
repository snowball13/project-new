\documentclass[11pt, oneside]{article}   	% use "amsart" instead of "article" for AMSLaTeX format
\usepackage{geometry}                		% See geometry.pdf to learn the layout options. There are lots.
\geometry{letterpaper}                   		% ... or a4paper or a5paper or ... 
%\geometry{landscape}                		% Activate for rotated page geometry
\usepackage[parfill]{parskip}    		% Activate to begin paragraphs with an empty line rather than an indent
\usepackage{graphicx}				% Use pdf, png, jpg, or epsÂ§ with pdflatex; use eps in DVI mode
								% TeX will automatically convert eps --> pdf in pdflatex		
\usepackage{caption}
\usepackage{subcaption}
\usepackage{float}
\graphicspath{ {../results/} }
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{bbm}

%SetFonts

%SetFonts

\usepackage{natbib}
\usepackage{url}
\bibliographystyle{elsarticle-harv}

\newcommand{\R}{\mathbb{R}}
\newcommand{\MN}{\mathbb{M}_N}
\newcommand{\LN}{\mathbb{L}_N}
\newcommand{\dsm}{d_\mathbb{S}(m)}
\newcommand{\dsmsq}{d^{2}_{\mathbb{S}}(m)}
\newcommand{\graddsmsq}{\nabla{d^{2}_{\mathbb{S}}(m)}}
\newcommand{\eone}{\hat{e}_1}
\newcommand{\etwo}{\hat{e}_2}
\newcommand{\bt}{\tilde{b}}
\newcommand{\pt}{\tilde{p}}
\newcommand{\dt}{\Delta t}
\newcommand{\M}{\mathbb{M}}
\newcommand{\N}{\mathbb{N}}
\newcommand{\Sb}{\mathbb{S}}
\newcommand{\Ps}{\mathbb{P}_{\mathbb{S}}}
\newcommand{\Pm}{\mathbb{P}_{\mathbb{M}_N}}
\newcommand{\Leb}{\mathrm{Leb}}
\newcommand{\DmDt}{\frac{\mathrm{D}m}{\mathrm{D}t}}
\newcommand{\DuDt}{\frac{\mathrm{D}u}{\mathrm{D}t}}



\title{MRes Report}
\author{Ben Snowball}
%\date{}							% Activate to display a given date or no date


\begin{document}



\maketitle
\section{Introduction}

\cite{hoskins1971atmospheric} introduced the the semi-geostrophic (SG) equations, an asymptotic limit as the Rossby number tends to \(0\) and the Froude number to \(\mathcal{O}(1)\) of the incompressible Euler-Boussinesq equations. \cite{cullen1993geometric} considered looking at a vertical slice model of these equations (the Eady model) that is used to look at the formation and evolution of weather fronts, by using a coordinate transformation to give an optimal transport interpretation of the SG equations (for further information on this, see \cite{cullen2006mathematical}).

\cite{visram2014framework} then compared the SG numerics with the standard Eady-Boussinesq numerics, and found that the standard Boussinesq solution does not go to the SG solution as the Rossby number tends to \(0\). They hypothesised that the standard numerics are going to the wrong solution due to numerical dissipation. This was the motivation to then look at a new Lagrangian method for this frontal problem in weather forecasting, to see if that will lead to a solution that will tend to the SG solution. 

This report is a first step in this direction. The main contribution is the construction of a version of an algorithm using the work of \cite{gallouet2016lagrangian} that avoids issues with artificial compressibility. The ultimate aim is to apply the method to the model, and see how it compares to the Eulerian solution.

In Section 2 of this report, we provide some background on the optimal transport approach and a symplectic timestepping method that will be part of our new method. In Section 3 we propose the method, and detail how our program works when applied to two examples: a simple Beltrami flow in a unit square, and a situation of a number of vortices placed in a unit square. We then in Section 4 present some results and finally give an outlook on where this work can head next in Section 5.


\section{Background}

\subsection{Optimal Transport Approach}

We aim to build a method with a Lagrangian approach for solving the Eady model. The Euler equations describe fluid particle motion under an incompressibility constraint. \cite{brenier1989least} introduced the idea of "distance" between a Lagrangian flow map and the space of measure preserving maps, which naturally leads to the constraint of incompressibility being equivalent to this distance being zero. The challenge here is representing this constraint numerically.

Consider two maps \(m_1, m_2 \: : \: \Omega \to \Omega\) for some domain \(\Omega \subset \R^n, \: n \in \N\). We can define a distance between these two maps simply by using the \(L^2\)-norm, i.e. letting \(\M := L^2(\Omega)\), 
\begin{align}
d^2(m_1, m_2) := \int_\Omega || m_1(a) - m_2(a) ||^2 \: \mathrm{d}^2 a, \quad m_1, m_2 \in \M.
\end{align}

We can extend this to define a notion of distance for any map in \(\M\) to the set of measure preserving maps of \(\M\). Denoting \(\Sb\) as this set, i.e. 
\begin{align}
\Sb &= \Big\{ \: s \in \M \quad | \quad s_{\#}\Leb(A) := \Leb(s^{-1}(A)) = \Leb(A) \quad \forall A \subset \Omega \Big\},
\end{align}
(so \(\Sb \subset \M\)) where \(\Leb\) is the Lebesque measure on \(\Omega\), we can define the (squared) distance from a map in \(\M\) to the set \(\Sb\) by \(d^2_\Sb \: : \: \M \to \R\) where
\begin{align}
\dsmsq := \min_{s \in \mathbb{S}} d^2(m, s), \quad m \in \M.
\end{align}
It follows then then that for a configuration \(m\), \(\dsmsq = 0\) is equivalent to the configuration being incompressible.

\cite{gallouet2016lagrangian} introduced the idea of discretising our function space. For \(N \in \N\), we define a tessellation partition \(P_N\) of \(\Omega\) into \(N\) subsets \(\omega_i, i=1,\dots,N\) such that:
\begin{align}
1)& \quad \Leb(\omega_i) = \frac{1}{N}\Leb(\Omega) \quad \forall i = 1,\dots,N \\
2)& \quad \max_{i = 1,\dots,N} \mathrm{diam}(\omega_i) \le CN^{-\frac{1}{2}}, \quad C \text{ independent of } N.
\end{align}
Then we define \(\MN\) to be the space of functions from \(\Omega\) to \(\R^n\) which are constant on each of the subdomains \(\omega_i\) of \(P_N\), i.e.
\begin{align}
\MN &= \Big\{ \phi \: : \: \Omega \to \R^n \quad | \quad \phi | _{\omega_i} \text{ is constant, } i = 1,\dots,N \Big\}.
\end{align}
Note that of course our notion of distance for any map in \(\MN\) to \(\Sb\) still holds. Discretising in this way, i.e. representing functions as piecewise constant maps, allows us to store computationally a map as merely as set of points (the value of the map on each subdomain \(\omega_i\)).

For clarity, in this report, we refer to \(m \in \MN\)  as being a collection of particles, where each particle \(i=1,\dots,N\) has its own subdomain \(\omega_i\), and simply holds the values of \(m(\omega_i)\) and \(u(\omega_i)\) for its position and velocity respectively.

The Hamiltonian approach for solving the problem is then: choose a set of variables \((m, u) \in \MN \times \MN \) that satisfy Hamilton's equations
\begin{align} 
\dot{m} &= u, \\
\dot{u} &= - \nabla p
\end{align}
where \(\nabla p = \frac{\graddsmsq}{2\epsilon^2}\). Here, \(\epsilon\) is the spring parameter. This is the system of equations corresponding to conserving the Hamiltonian
\begin{align} 
H(m, u) &= \frac{1}{2} ||u||^2_{L^2} + \frac{\dsmsq}{2\epsilon^2}.
\end{align}
Conserving the Hamiltonian keeps the system close to incompressible when \(\epsilon\) is small,  stiff spring. 

From \cite{gallouet2016lagrangian}, a calculatable formula for \(\graddsmsq\) exists. First, we introduce the definition of a Laguerre diagram and briefly explain the projections used as part the formula. Let \(M = (M_1,\dots,M_N), \text{ where } M_i \in \R^n, \psi = (\psi_1,\dots,\psi_N), \text{ where } \psi_i \in \R\). The Laguerre diagram is a decomposition of \(\R^2\) into \(N\) convex polyhedra (Laguerre cells) defined by
\begin{align}
\mathrm{Lag}_i(M, \psi) &:= \Big\{ x \in \R^n \quad | \quad || x - M_i ||^2 + \psi_i \le || x - M_j ||^2 + \psi_j, \quad \forall j = 1,\dots,N \Big\}
\end{align}

Since \(\Sb\) is closed but not convex, the orthogonal projection of a map in \(\Sb\) exists, but is not uniquely defined. Thus it is simply given as any map that is a projection. In other words, a projection of \(m \in \M\), \(P_\Sb(m)\), is any point satisfying
\begin{align}
|| P_\Sb(m) - m ||^2 &= \dsmsq.
\end{align}
We also denote the orthogonal projection mapping on \(\MN\) by \(P_{\MN}\). The following proposition was proved by \cite{gallouet2016lagrangian}.

Proposition 1: Let \(m \in \MN\) and define \(M_i := m(\omega_i) \in \R^n \text{ for } i = 1,\dots,N\) with \(M = (M_1,\dots,M_N)\). Then there exists \(\psi = (\psi_1,\dots,\psi_N), \psi \in \R\), unique up to additive constant such that, with \(L_i := \mathrm{Lag}_i(M, \psi)\), 
\begin{align}
\Leb(L_i) &= \frac{1}{N}\Leb(\Omega),
\end{align}
and
\begin{align}
\dsmsq & = \sum_{i=1}^N \: \int_{L_i} || x - M_i ||^2 \: \mathrm{d}x, \\
\graddsmsq &= 2 \big( m - P_{\MN} \circ P_{\mathbb{S}}(m) \big),
\end{align}
where
\begin{align}
P_{\MN} \circ P_{\mathbb{S}}(m) &= \sum^N_{i=1} B_i \mathbbm{1}_{L_i}(m), \\
B_i &:= \frac{1}{\Leb(L_i)} \int_{L_i} x \: \mathrm{d}x, \quad i = 1,\dots,N. 
\end{align}

We note that finding the \(\psi\)'s that satisfy equation (12) is equivalent to solving a linear program, that can be solved using the simplex algorithm that is \(\mathcal{O}(N^3\log N)\). \cite{gallouet2016lagrangian} instead used a damped Newton algorithm \citep{merigot2017algorithm}, an efficient iterative method that we also implement and hope will be much faster. This algorithm, together with equations (13, 14) above, are implemented in a code library \citep{merigotpymongeampere}, which is used in \cite{gallouet2016lagrangian}. 

\cite{gallouet2016lagrangian} used a symplectic method (symplectic Euler) to discretise (7, 8) in time. For initial conditions \((m^0, u^0) \in \MN \times \MN \), the algorithm is as follows:
\begin{flalign*}
 & \quad
 \begin{cases}
  u^{n+1} = u^n - \dt \; \frac{\nabla d^2_\Sb(m^n)}{2\epsilon^2} \\
  m^{n+1} = m^n + \dt \; u^{n+1}
 \end{cases}&& 
\end{flalign*}
where \(\graddsmsq\) is given by (14). We note a symplectic map is one that preserves phase space volume. (Consider a surface in the phase space made up of points of initial condition. At a time \(t\) each initial condition point will have been mapped to a new position in the phase space. If we consider all these new mappings to also make up a surface, then the flow was symplectic if the volume enclosed by the original surface is the same for that of the new surface. A timestepping method is symplectic if the volume is preserved at each timestep.)

Computationally, problems arose with extending this method to geophysical fluids problems due to the difficulty in tuning the \(\epsilon\) parameter. We thus wanted our method to get rid of the need for the tuning of the parameter \(\epsilon\), that, as well as being difficult to tune, was being used to represent small oscillations that may interact with the internal waves of the Eady model, taking the flow out of hydrostatic balance. The subsequent idea was to answer the question "how do we remove the need for \(\epsilon\) and get rid of compressibility?".

\subsection{RATTLE Algorithm and Symplecticity}

\cite{leimkuhler1994symplectic} describes the RATTLE algorithm that we modify to be part of our timestepping method. \cite{verlet1967computer} used a two-step discretisation for unconstrained problems like (7, 8), originally devised to be applied to molecular dynamics simulations. \cite{ryckaert1977numerical} introduced a direct numerical integration scheme called SHAKE based on the Verlet method that incorporates a holonomic constraint on the system (a constraint on one of the variables). \cite{andersen1983rattle} adapted this into the basis for an algorithm known as RATTLE, that preserves other invariants.

For clarity, the RATTLE algorithm as described by \cite{leimkuhler1994symplectic} is as follows. Consider the constrained system
\begin{align}
\dot{q} &= p, \\
\dot{p} &= - \nabla_q V(q) + \lambda g'(q), \\
g(q) &= 0
\end{align}
The RATTLE algorithm is then:
\begin{flalign*}
 & \quad
 \begin{cases}
  q^{n+1} = m^{n} + \dt \; u^{n+1/2}  \\
  p^{n+1/2} = p^n - \frac{\dt}{2} \nabla_q V(q^n) + \frac{\dt}{2} \lambda^n g'(q^n) \\
  \quad \text{where } \lambda^n \text{ is chosen so that } g'(q^{n+1}) = 0
 \end{cases}&& \\
 & \quad \text{and, } \\
 & \quad 
 \begin{cases}
  p^{n+1} = p^{n+1/2} - \frac{\dt}{2} \nabla_q V(q^{n+1}) + \frac{\dt}{2} \lambda^n g'(q^{n+1}) \\
  \quad \text{where } \hat{\lambda}^{n+1} \text{ is chosen so that } g'(q^{n+1})p^{n+1} = 0
 \end{cases} 
\end{flalign*}
where the superscript \(n\) refers to the current timestep, and \(\dt\) is the time step size.

For a symplectic timestepping method, there exists a modified Hamiltonian \(H'(p, q) = H(p, q) + \dt^k \Delta H(p, q, \dt)\) if \(H\) is infinitely differentiable, such that solutions of the modified Hamiltonian system corresponding to \(H'\) pass exactly through the points gained at each timestep of the method, i.e. it conserves the modified Hamiltonian \(H'\). For a constrained system with a holonomic constraint \(g(q)\) and modified Hamiltonian \(H(p, q)\) the constrained Hamiltonian is
\begin{align}
H_c(p, q) = H(p, q) + \lambda g(q)
\end{align}
which leads to the system
\begin{align}
\dot{q} &= \frac{\partial H_c}{\partial p} = \frac{\partial H}{\partial p} \\
\dot{p} &= - \frac{\partial H_c}{\partial q} = - \Big( \frac{\partial H}{\partial q} + \lambda \frac{\partial g}{\partial q} \Big) \\
0 &= \frac{\partial H_c}{\partial \lambda} = g(q)
\end{align}
As we can see, (21-23) is another way of writing (17-19) for \(H(p, q) = \frac{p^2}{2} + V(q)\).

Hamiltonian systems of differential equations like (7, 8) have a flow that preserves a symplectic structure. Importantly, it has been established that symplectic methods have better long-term stability properties than non-symplectic methods \citep{okunbor1992explicit}. In \cite{ruth1983canonical} it was noted that the Verlet method is symplectic, and \cite{leimkuhler1994symplectic} confirms that RATTLE is also symplectic. 

For a constrained system, the constraint \(g\) must also be infinitely differentiable for the modified (and constrained) Hamiltonian to be exist. This is not the case for our constrained system, meaning that although our method is symplectic, it is not conserving of the modified Hamiltonian.


\section{Method}

In this section we introduce our timestepping method that combines aspects of the optimal transport approach and the RATTLE algorithm for constrained systems. We can formulate the simple flow problem as a constrained problem as follows. Here, we consider \(n=2\), i.e. our domain \(\Omega \subset \R^2\). The non-discretised incompressible Euler equations can be written in Lagrangian form as:
\begin{align}
& \dot{m}(a, t) = u(a,t), \quad \text{contraint}: \: \dsmsq = 0 \\
\iff
 &\begin{cases}
  \dot{m} = u \\
  \dot{u} = \lambda \graddsmsq, \quad \lambda = \lambda(t) \text{ a Lagrange multiplier enforcing } \dsmsq = 0.
 \end{cases} 
\end{align}
Referring to equations (17-19), we are just setting \(V(\cdot) \equiv 0\) and \(g(\cdot) = d^2_{\Sb}(\cdot)\).

Restricting \(m\) to be in \(\MN\) would mean we cannot enforce the constraint. To address this, we choose an initial configuration of particles \(m^0\) using a version of Lloyd's algorithm \citep{merigot2017algorithm}. This is an iterative algorithm that initially randomly chooses a configuration of the particles in the domain. The process then calculates the Laguerre cells for each particle so that (12) is satisfied, and "moves" the particles so that each is set as the centroid of its respective cell, before the process is repeated. If Loyd's algorithm converges, then one has found configuration \(m\) such that \(m - P_{\MN} \circ P_{\mathbb{S}}(m) = 0\), meaning that one has found a local minimum for \(\graddsmsq = 2 \big( m - P_{\MN} \circ P_{\mathbb{S}}(m) \big) \). We then set
\begin{align}
c &:= d^{2}_{\mathbb{S}}(m^{0})
\end{align}
so \(c\) is independent of \(t\) and gives the "distance" from an incompressible state that the particles initially lie. We then solve
\begin{align}
 &\begin{cases}
  \dot{m} = u \\
  \dot{u} = \lambda \graddsmsq, \quad \lambda = \lambda(t) \text{ a Lagrange multiplier enforcing } \dsmsq = c.
 \end{cases} 
\end{align}
so that we keep the particle positions at this small initial distance \(c\) from incompressible. 

Define, for each timestep \(n\), \(b^n := \nabla{d^{2}_{\Sb}(m^n)}\). Our modified RATTLE algorithm, applied to this problem, is then:

Algorithm 1:
\begin{flalign*}
 & \quad
 \begin{cases}
  m^{n+1} = m^{n} + \dt \; u^{n+1/2}  \\
  u^{n+1/2} = u^n - \frac{\dt}{2} \lambda^n b^n \\
  b^{n+1} - c = 0
 \end{cases}&& \\
 & \quad \text{and, } \\
 & \quad 
 \begin{cases}
  u^{n+1} = u^{n+1/2} - \frac{\dt}{2} \hat{\lambda}^{n+1} b^{n+1} \\
  u^{n+1} \cdot b^{n+1} = 0.
 \end{cases} 
\end{flalign*}

For clarity, we note that the constraint in the first bracketed section of the algorithm is used to find the Lagrange multiplier \(\lambda^n\) such that the constraint is satisfied, which is then used to calculate \(u^{n+1/2}\) and hence \(m^{n+1}\). We do this using an iterative method. For the second bracketed section, the Lagrange multiplier \(\hat{\lambda}^{n+1}\) can be calculated directly from the constraint with no need for an iterative method.

Pseudo-Code for Algorithm 1:
\begin{flalign}
& \quad \text{Set } m^0, u^0, \text{ and define }b^0 = \nabla{d^{2}_{\Sb}(m^0)} && \nonumber \\
& \quad \text{FOR } n = 0,1,\dots \nonumber \\
& \quad \quad \text{Define } h(\lambda) := d^{2}_{\Sb}(m^n + \dt \; u^n - \frac{\dt}{2} \lambda b^n) - c \\
& \quad \quad \text{Solve, for } \lambda^n: h(\lambda^n) = 0 \nonumber \\
& \quad \quad \text{Set } u^{n+1/2} = u^n - \frac{\dt}{2} \lambda^n b^n \nonumber \\
& \quad \quad \text{Set } m^{n+1} = m^{n} + \dt \; u^{n+1/2} \nonumber \\
& \quad \quad \text{Set } b^{n+1} = \nabla{d^{2}_{\Sb}(m^{n+1})} \nonumber \\
& \quad \quad \text{Set } \hat{\lambda}^{n+1} = \frac{2 \; u^{n+1} \cdot b^{n+1}}{\dt \; || b^{n+1} || ^2} \nonumber \\
& \quad \quad \text{Set } u^{n+1} = u^{n+1/2} - \frac{\dt}{2} \hat{\lambda}^{n+1} b^{n+1} \nonumber
\end{flalign}

Newton was found to be ineffective for solving \(h(\lambda^n) = 0\) for \(\lambda^n\) as the second derivative of \(h\) does not exist - in fact, \cite{gallouet2016lagrangian} showed that the first derivative of \(d^2_\Sb(\cdot)\) only exists almost everywhere. Instead, we use a black-box type of algorithm that is derivative-free. Plotting the function \(h(\lambda^n)\) for various timesteps, we see that the behaviour of \(h\) is actually quite pleasant and that we only have a maximum of two roots for \(h\) (instead of potentially an oscillating function with many roots) (see figure \ref{fig:h-lambda}). Thus, we can find a physical root for \(h\) quite easily. In this case, as this is a 1-dimensional problem, we use SciPy's optimize.root() method. 

Upon using this algorithm on the Beltrami flow example, we found that it did not behave as desired if we increased the tolerance of the constraint, i.e. set
\begin{align}
c := 2 \; d^2_\Sb (m^0)
\end{align}
(see Section 4: Results). The reason being that the system was being over-constrained, as the particles can actually get closer to incompressible than the constraint would allow. In Algorithm 1, the \(b^n\) term can be noisy, and so we do not wish to nudge the particles in a noisy direction every timestep.

This motivated us to present an different formulation, where the algorithm incorporates an inequality constraint instead of the equality constraint seen in Algorithm 1, so that we just desire that the particle positions lie within the tolerance \(c\) from incompressible. Thus, our problem is
\begin{align}
 &\begin{cases}
  \dot{m} = u \\
  \dot{u} = \lambda \graddsmsq, \quad \lambda = \lambda(t) \text{ a Lagrange multiplier enforcing } \dsmsq \le c.
 \end{cases} 
\end{align}

and our modified RATTLE algorithm, applied to this problem, is then:

Algorithm 2:
\begin{flalign*}
 & \quad \text{IF } (m^n + \dt \; u^n < c) && \\
 & \quad \quad \text{set } m^{n+1} = m^n + \dt \; u^n, \: \: u^{n+1} = u^n \\
 & \quad \text{ELSE } \\
 & \quad \quad \begin{cases}
  m^{n+1} = m^{n} + \dt \; u^{n+1/2}  \\
  u^{n+1/2} = u^n - \frac{\dt}{2} \lambda^n b^n \\
  b^{n+1} - c = 0
 \end{cases} \\
 & \quad \quad \text{and, } \\
 & \quad \quad \begin{cases}
  u^{n+1} = u^{n+1/2} - \frac{\dt}{2} \hat{\lambda}^{n+1} b^{n+1} \\
  u^{n+1} \cdot b^{n+1} = 0.
 \end{cases} 
\end{flalign*}

Pseudo-Code for Algorithm 2:
\begin{flalign}
& \quad \text{Set } m^0, u^0, \text{ and define }b^0 = \nabla{d^{2}_{\Sb}(m^0)} && \nonumber \\
& \quad \text{FOR } n = 0,1,\dots \nonumber \\
& \quad \quad \text{IF } (m^n + \dt \; u^n < c) && \nonumber \\
& \quad \quad \quad \text{Set } m^{n+1} = m^n + \dt \; u^n \nonumber \\
& \quad \quad \quad \text{Set } u^{n+1} = u^n \nonumber \\
& \quad \quad \text{ELSE } \nonumber \\
& \quad \quad \quad \text{Define } h(\lambda) := d^{2}_{\Sb}(m^n + \dt \; u^n - \frac{\dt}{2} \lambda b^n) - c \\
& \quad \quad \quad \text{Solve, for } \lambda^n: h(\lambda^n) = 0 \nonumber \\
& \quad \quad \quad \text{Set } u^{n+1/2} = u^n - \frac{\dt}{2} \lambda^n b^n \nonumber \\
& \quad \quad \quad \text{Set } m^{n+1} = m^{n} + \dt \; u^{n+1/2} \nonumber \\
& \quad \quad \quad \text{Set } b^{n+1} = \nabla{d^{2}_{\Sb}(m^{n+1})} \nonumber \\
& \quad \quad \quad \text{Set } \hat{\lambda}^{n+1} = \frac{2 \; u^{n+1} \cdot b^{n+1}}{\dt \; || b^{n+1} || ^2} \nonumber \\
& \quad \quad \quad \text{Set } u^{n+1} = u^{n+1/2} - \frac{\dt}{2} \hat{\lambda}^{n+1} b^{n+1} \nonumber
\end{flalign}


\section{Results}

\begin{figure}[H]
   \begin{subfigure}[t]{0.4\textwidth}
        \centering
	\includegraphics[scale=0.3]{rattle-test/hvals000}
        \caption{} \label{fig:h-lambda-000}
    \end{subfigure}
    \begin{subfigure}[t]{0.4\textwidth}
        \centering
	\includegraphics[scale=0.3]{rattle-test/hvals009}
        \caption{} \label{fig:h-lambda-009}
    \end{subfigure}
\centering
\caption{Plots of h(\(\lambda\)) as given in equation (31) for \(\lambda\) values \(-5000,-4900,\dots,5000\) at two timesteps of our new method (Algorithm 2), when applied to the Beltrami flow example. (a) After 0 timesteps. (b) After 10 timesteps.}
\centering
\label{fig:h-lambda}
\end{figure}

In this section we present numerically calculated convergence results of our method detailed in Algorithm 2, with the computer code written in Python based on the pseudo-code for Algorithm 2 detailed in Section 3, utilising the code-library of \cite{gallouet2016lagrangian} \citep{merigotpymongeampere}. We also present comparisons with the code of \cite{gallouet2016lagrangian}, as well as displaying some results of our method when applied to a more complex example.

We first look at the relationship between the initial distance from incompressible (c value) and the number of particles used for the initialisation of the model (N value). Recall that the initial configuration of particles \(m^0\) is found using a version of Lloyd's algorithm \citep{merigot2017algorithm}, an iterative algorithm that initially randomly chooses a configuration of the particles in the domain, calculates the Laguerre cells for each particle so that (12) is satisfied, and "moves" the particles to that each is set as the centroid of its respective cell, before the process is repeated. We then set \(c = d^{2}_{\mathbb{S}}(m^{0})\) as described in equation (26), so that \(c\) is the squared distance that the initial configuration was from being incompressible. Figure \ref{fig:c-N} shows that \(c \propto 1/N\) i.e. an inversely proportional relationship. This indicates that as we increase the number of particles used for our run, the error from being incompressible upon setup decreases linearly.

\begin{figure}[H]
\includegraphics[scale=0.5]{rattle-test/c-N}
\centering
\caption{A plot of initial distances from incompressible (c values) against the number of particles used for the initialisation (N values) on a log-log plot [black crosses]. Here we have used 50 N values from 500 to 25000 in intervals of 500. Also plotted is a line of slope -1 on the log-log scale [blue line]. Recall that the initial configuration of particles \(m^0\) is found using a version of Lloyd's algorithm \citep{merigot2017algorithm}, and c is set as the squared distance that the initial configuration was from being incompressible. }
\centering
\label{fig:c-N}
\end{figure}

To test our method further, we use two examples. First, we have a simple Beltrami flow in a unit square, with each particle being initialised with a position \(m^0\) and velocity \(u^0 = U(m^0)\) where
\begin{align}
U(m) = \big( -\cos(m_0 \pi) \sin(m_1 \pi), \: \: \sin(m_0 \pi) \cos(m_1 \pi) \big)
\end{align}
where \(m_0, \: m_1\) are the horizontal and vertical components of the position \(m\) respectively. Note the Eulerian solution is time independent. In figure \ref{fig:error-N} we see that \(\text{e}_{rr} \propto 1/N^{2.86}\), where \(\text{e}_{rr}\) is the \(L^2\mathrm{-error}\) over all particles,
\begin{align}
\text{e}_{rr} = \Big( \frac{1}{N} \sum_{p = 1}^{N} || u^{n_T}_{(p)} - U(m^{n_T}_{(p)}) ||^2 \Big) ^\frac{1}{2}
\end{align}
where \(m^{n_T}_{(p)}, u^{n_T}_{(p)}\) are the position and corresponding velocity of the particle \(p\) after \(n_T\) timesteps. The relationship seen in figure \ref{fig:error-N} indicates that the error decreases as we increase the number of particles used in the run. For figure \ref{fig:error-N}, we used 120 timesteps and an end time of 0.5s (and so a step size of \(\dt = 0.004167\)) for each run. 

\begin{figure}[H]
\includegraphics[scale=0.5]{beltrami-square-rattle/error-N}
\centering
\caption{A plot of the final L2-norm error after a run of 0.5s using 120 timesteps (and so a step size of \(\dt = 0.004167\)) against the number of particles used for the initialisation (N values) on a log-log plot [black crosses], using our new method (Algorithm 2). Here we have used 8 N values from 2500 to 20000 in intervals of 2500. Also plotted is a line of slope \(0.35\) on the log-log scale [blue line].}
\centering
\label{fig:error-N}
\end{figure}

We next look at comparing the two methods outlined in Section 3 - Algorithm 1 with the equality constraint and Algorithm 2 with the inequality constraint. We run both on the Beltrami flow over a time period of 1s, using \(N = 1000\) particles and a step size of \(\dt = 0.004s\). Figure \ref{fig:beltrami-flow} shows a visualisation of the flow using three snapshots of the simulation when using each algorithm.  For the equality constrained method, we set the constraint value \(c\) according to equation (26) in figures \ref{fig:beltrami-flow-000-e1}, \ref{fig:beltrami-flow-125-e1} and \ref{fig:beltrami-flow-249-e1}, and equation (29) in figures \ref{fig:beltrami-flow-000-e2}, \ref{fig:beltrami-flow-125-e2} and \ref{fig:beltrami-flow-249-e2}. For the inequality constrained method (Algorithm 2) we keep the constraint value \(c\) as equation (26). We see that the equality constraint performs poorly when \(c\) is set as equation (29), resulting in an incorrect visualisation of the flow, while the other two visualisations compare well.

\begin{figure}[H]
     \begin{subfigure}[t]{0.25\textwidth}
        \centering
        \includegraphics[scale=0.2]{beltrami-square-rattle-equality/N=1000-endt=1-nt=250-dt=0.004-c_scaling=1/000}
        \caption{} \label{fig:beltrami-flow-000-e1}
    \end{subfigure}
    \begin{subfigure}[t]{0.25\textwidth}
        \centering
        \includegraphics[scale=0.2]{beltrami-square-rattle-equality/N=1000-endt=1-nt=250-dt=0.004-c_scaling=1/125}
        \caption{} \label{fig:beltrami-flow-125-e1}
    \end{subfigure}
   \begin{subfigure}[t]{0.25\textwidth}
        \centering
	\includegraphics[scale=0.2]{beltrami-square-rattle-equality/N=1000-endt=1-nt=250-dt=0.004-c_scaling=1/249}
        \caption{} \label{fig:beltrami-flow-249-e1}
    \end{subfigure}
   \begin{subfigure}[t]{0.25\textwidth}
        \centering
        \includegraphics[scale=0.2]{beltrami-square-rattle-equality/N=1000-endt=1-nt=250-dt=0.004-c_scaling=2/000}
        \caption{} \label{fig:beltrami-flow-000-e2}
    \end{subfigure}
   \begin{subfigure}[t]{0.25\textwidth}
        \centering
        \includegraphics[scale=0.2]{beltrami-square-rattle-equality/N=1000-endt=1-nt=250-dt=0.004-c_scaling=2/035}
        \caption{} \label{fig:beltrami-flow-125-e2}
    \end{subfigure}
   \begin{subfigure}[t]{0.25\textwidth}
        \centering
	\includegraphics[scale=0.2]{beltrami-square-rattle-equality/N=1000-endt=1-nt=250-dt=0.004-c_scaling=2/040}
        \caption{} \label{fig:beltrami-flow-249-e2}
    \end{subfigure}
   \begin{subfigure}[t]{0.25\textwidth}
        \centering
        \includegraphics[scale=0.2]{beltrami-square-rattle/N=1000-endt=1-nt=250-dt=0.004-c_scaling=1/000}
        \caption{} \label{fig:beltrami-flow-000-i}
    \end{subfigure}
   \begin{subfigure}[t]{0.25\textwidth}
        \centering
        \includegraphics[scale=0.2]{beltrami-square-rattle/N=1000-endt=1-nt=250-dt=0.004-c_scaling=1/125}
        \caption{} \label{fig:beltrami-flow-125-i}
    \end{subfigure}
   \begin{subfigure}[t]{0.25\textwidth}
        \centering
	\includegraphics[scale=0.2]{beltrami-square-rattle/N=1000-endt=1-nt=250-dt=0.004-c_scaling=1/249}
        \caption{} \label{fig:beltrami-flow-249-i}
    \end{subfigure}
\centering
\caption{The equality constrained Algorithm 1 and inequality constrained Algorithm 2 running the Beltrami flow example over a time period of 1s. The number of particles used is \(N = 1000\), with a step size of \(\dt = 0.004s\). (a), (b), (c) Three snapshots of the Laguerre cells along with their centres (coloured dots) indicating the particle positions using the method of Algorithm 1, where \(c := d^2_\Sb (m^0)\). ((a) Initial positions, (b) after 125 timesteps, (c) after 249 timesteps). (d), (e), (f) Three snapshots of the Laguerre cells along with their centres (coloured dots) indicating the particle positions using the method of Algorithm 1, where \(c := 2 \; d^2_\Sb (m^0)\). ((d) Initial positions, (e) after 125 timesteps, (f) after 249 timesteps). (g), (h), (i) Three snapshots of the Laguerre cells along with their centres (coloured dots) indicating the particle positions using the method of Algorithm 2, where \(c := d^2_\Sb (m^0)\). ((g) Initial positions, (h) after 125 timesteps, (i) after 249 timesteps). Note the colours used are only to help distinguish the particles as they travel.}
\centering
\label{fig:beltrami-flow}
\end{figure}

We also look at comparing these results with that of \cite{gallouet2016lagrangian} when running the same Beltrami flow (over a time period of 1s, using \(N = 1000\) particles and a step size of \(\dt = 0.004s\)). Figure \ref{fig:beltrami-flow} shows a visualisation of the flow using three snapshots of the simulation when using each algorithm (the method of \cite{gallouet2016lagrangian}, and the inequality constrained Algorithm 2). We can see that the results compare well. Further, we also see that in figure \ref{fig:beltrami-flow-energies} that the calculated energy of the system at each timestep stays relatively constant, showing no real oscillations or dissipation. This is compared to figures \ref{fig:beltrami-flow-energies-q} and \ref{fig:beltrami-flow-energies-q-ke}, where we see a significant oscillation of the total energy of the system when using the method described in \cite{gallouet2016lagrangian}. The energy at timestep \(n\) in figure \ref{fig:beltrami-flow-energies-q} is calculated as
\begin{align}
E^n = \frac{1}{N} \Big( \sum_{p = 1}^{N} \frac{1}{2} || u^n_{(p)} ||^2 + \frac{1}{2 \epsilon^2} d^2_{\Sb}(m^n) \Big) 
\end{align} 
[I know that the final term is wrong here, but I am struggling to think of how to write it.]
which is the Lagrangian approximation of the integral of the modified Hamiltonian given in equation (9) over the whole domain \(\Omega\). The energy at timestep \(n\) in figure \ref{fig:beltrami-flow-energies-q-ke} is simply just the kinetic energy of the system, i.e.
\begin{align}
E^n = \frac{1}{N} \sum_{p = 1}^{N} \frac{1}{2} || u^n_{(p)} ||^2
\end{align} 
which is the Lagrangian approximation of the kinetic energy over the whole domain \(\Omega\). This kinetic energy is then comparable to figure \ref{fig:beltrami-flow-energies} which shows the energy as equation (32) also, i.e. the integral of the Hamiltonian
\begin{align}
H(m, u) = \frac{1}{2} || u ||^2.
\end{align}

\begin{figure}[H]
     \begin{subfigure}[t]{0.25\textwidth}
        \centering
        \includegraphics[scale=0.2]{beltrami-square/RT-N=1000-tmax=1-nt=250-eps=0.1/000}
        \caption{} \label{fig:beltrami-flow-000-q}
    \end{subfigure}
    \begin{subfigure}[t]{0.25\textwidth}
        \centering
        \includegraphics[scale=0.2]{beltrami-square/RT-N=1000-tmax=1-nt=250-eps=0.1/125}
        \caption{} \label{fig:beltrami-flow-125-q}
    \end{subfigure}
   \begin{subfigure}[t]{0.25\textwidth}
        \centering
	\includegraphics[scale=0.2]{beltrami-square/RT-N=1000-tmax=1-nt=250-eps=0.1/249}
        \caption{} \label{fig:beltrami-flow-249-q}
    \end{subfigure}
   \begin{subfigure}[t]{0.25\textwidth}
        \centering
        \includegraphics[scale=0.2]{beltrami-square-rattle/N=1000-endt=1-nt=250-dt=0.004-c_scaling=1/000}
        \caption{} \label{fig:beltrami-flow-000}
    \end{subfigure}
   \begin{subfigure}[t]{0.25\textwidth}
        \centering
        \includegraphics[scale=0.2]{beltrami-square-rattle/N=1000-endt=1-nt=250-dt=0.004-c_scaling=1/125}
        \caption{} \label{fig:beltrami-flow-125}
    \end{subfigure}
   \begin{subfigure}[t]{0.25\textwidth}
        \centering
	\includegraphics[scale=0.2]{beltrami-square-rattle/N=1000-endt=1-nt=250-dt=0.004-c_scaling=1/249}
        \caption{} \label{fig:beltrami-flow-249}
    \end{subfigure}
\centering
\caption{The method of \cite{gallouet2016lagrangian} and our new method running the Beltrami flow example over a time period of 1s. The number of particles used is \(N = 1000\), with a step size of \(\dt = 0.004s\). (a), (b), (c) Three snapshots of the Laguerre cells along with their centres (coloured dots) indicating the particle positions using the method of \cite{gallouet2016lagrangian}. ((a) Initial positions, (b) after 125 timesteps, (c) after 249 timesteps). (d), (e), (f) Three snapshots of the Laguerre cells along with their centres (coloured dots) indicating the particle positions using our new method. ((d) Initial positions, (e) after 125 timesteps, (f) after 249 timesteps). Note the colours used are only to help distinguish the particles as they travel.}
\centering
\label{fig:beltrami-flow}
\end{figure}
 
\begin{figure}[H]
   \begin{subfigure}[t]{0.4\textwidth}
        \centering
	\includegraphics[scale=0.3]{beltrami-square/RT-N=1000-tmax=1-nt=250-eps=0.1/energies}
        \caption{} \label{fig:beltrami-flow-energies-q}
    \end{subfigure}
    \begin{subfigure}[t]{0.4\textwidth}
        \centering
	\includegraphics[scale=0.3]{beltrami-square/RT-N=1000-tmax=1-nt=250-eps=0.1/kinetic_energies}
        \caption{} \label{fig:beltrami-flow-energies-q-ke}
    \end{subfigure}
   \begin{subfigure}[t]{0.4\textwidth}
        \centering
	\includegraphics[scale=0.3]{beltrami-square-rattle/N=1000-endt=1-nt=250-dt=0.004-c_scaling=1/energies}
        \caption{} \label{fig:beltrami-flow-energies}
    \end{subfigure}
\centering
\caption{The method of \cite{gallouet2016lagrangian} and our new method running the Beltrami flow example over a time period of 1s. The number of particles used is \(N = 1000\), with a step size of \(\dt = 0.004s\). (a) A plot of residual (difference between initial and current value) of the total modified energy of the system against time for the run using the method of \cite{gallouet2016lagrangian}. (b) A plot of the residual of just the kinetic energy of the system against time for the run using the method of \cite{gallouet2016lagrangian}. (c) A plot the residual of the total (kinetic) energy of the system against time for the run using our new method.}
\centering
\label{fig:beltrami-flow-energy}
\end{figure}
 
Our second example, still in the unit square, has \(n_V\) vortices placed in the domain with centres at positions \(C_i\) and weights \(w_i, \: i = 1,\dots,n_V\). Each particle is initialised with a position \(m^0\) and a and velocity \(u^0 = U(m^0)\) where
\begin{align}
U(m) &= \nabla^\perp \phi(m), \\
\phi(m) &= \sum_{i=1}^{n_v} w_i \: \exp \Big( \frac{|| m - C_i ||^2}{2 \sigma^2} \Big)
\end{align}
where \(\sigma\) is the standard deviation of the vortex strength from the centre.

Figures \ref{fig:vortices-000}, \ref{fig:vortices-1000} and \ref{fig:vortices-1900} show a visualisation of the flow, over a time period of 1s. The number of particles used is \(N = 2000\), with a step size of \(\dt = 0.0005s\). We used \(n_V = 3\) vortices with centres \(C_1 = [0.25, 0.25], C_2 = [0.75, 0.25] \) and \(C_3 = [0.5, 0.75]\) with weights \(w_1 = w_2 = w_3 = 0.1\), and a standard deviation \(\sigma = 0.1\). Figures \ref{fig:vortices-quiver0}, \ref{fig:vortices-quiver1000} and \ref{fig:vortices-quiver1900}  show the velocity vectors at the same three snapshots. We also note the energy remains fairly constant, as seen in figure \ref{fig:vortices-energies}.

\begin{figure}[H]
   \begin{subfigure}[t]{0.25\textwidth}
        \centering
        \includegraphics[scale=0.2]{vortices/run1/000}
        \caption{} \label{fig:vortices-000}
    \end{subfigure}
   \begin{subfigure}[t]{0.25\textwidth}
        \centering
	\includegraphics[scale=0.2]{vortices/run1/1000}
        \caption{} \label{fig:vortices-1000}
    \end{subfigure}
   \begin{subfigure}[t]{0.25\textwidth}
        \centering
	\includegraphics[scale=0.2]{vortices/run1/1900}
        \caption{} \label{fig:vortices-1900}
    \end{subfigure}
   \begin{subfigure}[t]{0.25\textwidth}
        \centering
        \includegraphics[scale=0.2]{vortices/run1/quiver0}
        \caption{} \label{fig:vortices-quiver0}
    \end{subfigure}
   \begin{subfigure}[t]{0.25\textwidth}
        \centering
        \includegraphics[scale=0.2]{vortices/run1/quiver1000}
        \caption{} \label{fig:vortices-quiver1000}
    \end{subfigure}
   \begin{subfigure}[t]{0.25\textwidth}
        \centering
        \includegraphics[scale=0.2]{vortices/run1/quiver1900}
        \caption{} \label{fig:vortices-quiver1900}
    \end{subfigure}
   \begin{subfigure}[t]{1.\textwidth}
        \centering
	\includegraphics[scale=0.3]{vortices/run1/energies}
        \caption{} \label{fig:vortices-energies}
    \end{subfigure}
\centering
\caption{Our new method running the Vortices example over a time period of 1s. The number of particles used is \(N = 2000\), with a step size of \(\dt = 0.0005s\). We used \(n_V = 3\) vortices with centres \(C_1 = [0.35, 0.35], C_2 = [0.65, 0.35] \) and \(C_3 = [0.5, 0.65]\) with weights \(w_1 = w_2 = w_3 = 0.1\), and a standard deviation \(\sigma = 0.1\). (a), (b), (c) Three snapshots of the Laguerre cells along with their centres (coloured dots) indicating the particle positions. The colours used are only to help distinguish the particles as they travel. ((a) Initial positions, (b) after 1000 timesteps, (c) after 1900 timesteps). (d), (e), (f) Three snapshots of the velocities at different times using quiver plots. For each particle, the arrow direction indicates the direction of the velocity at that position, while the thickness indicates the magnitude of the velocity ((d) Initial positions, (e) after 1000 timesteps, (f) after 1900 timesteps). (g) A plot of the energy residual of the system against time. }
\centering
\label{fig:vortices}
\end{figure}


\section{Summary and Outlook}

The motivation for this report was to look for a new Lagrangian method for solving fronts in weather forecasting. In this report we have looked at setting out a potential new timestepping method for the incompressible Euler equations that involves optimal transport and a constrained symplectic algorithm. We have discussed some background to the method, as well as establishing its convergence numerically using a couple of examples. Our method gets rid of the need for the tuning of the parameter \(\epsilon\) from the method proposed by \cite{gallouet2016lagrangian}, that we found was difficult to tune as well as being used to represent small oscillations that may interact with the internal waves of the Eady model, taking the flow out of hydrostatic balance. Our method also seems to compare favourably with that of \cite{gallouet2016lagrangian} for the simple flows. 

When looking at implementing on the Eady model problem itself, we encountered issues relating to the aspect ratio of the large domain (about 100x larger in the horizontal than the vertical). One solution to this latter problem could be to redefine the distance metric used in the Laguerre cells definition given, to "penalise" distance moved in the vertical direction by the appropriate amount (the ratio). Ultimately, we would look to gain a mathematical proof for convergence and stability of the method, and look to implement it for the full Eady model problem with periodic boundary conditions, and see how it compares to the Eulerian solution.


\bibliography{mres}


\end{document}











  